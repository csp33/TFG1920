\documentclass[12pt,english]{article}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{pifont}
\usepackage{color}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{amsthm,thmtools}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{adjustbox}
\usepackage{url}
\usepackage{svg}
\usepackage{multirow}
\usepackage[hidelinks]{hyperref}
\usepackage{caption}
\usepackage{apacite}
\usepackage{amsthm}
\usepackage{multicol}
\usepackage{float}
\usepackage{amsfonts}
\usepackage[usestackEOL]{stackengine}
\usepackage{titling}
\usepackage{soul}
\usepackage{dirtree}
\usepackage{pgfplots}
\usepackage[nottoc]{tocbibind}
\usepackage{listings}
\usepackage{array}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{footnote}
\newcommand{\dollar}{\mbox{\textdollar}}
\usepackage{lscape}
\usepackage{incgraph}
\makesavenoteenv{tabular}
\makesavenoteenv{table}
\newcommand{\greentick}{\textcolor{green}{\ding{52}}}
\newcommand{\redcross}{\textcolor{red}{\ding{55}}}
\graphicspath{ {./img/}}
\makeatletter
\def\input@path{{input/}}
\makeatother
\selectlanguage{english}
%\usepackage{fancyhdr}
%\pagestyle{fancy}
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={4.0},
]{doclicense}
% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            %
}}
% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}


\lstset{
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  mathescape = true,
  basicstyle=\ttm,
  keywordstyle=\ttb\color{deepblue},
  emph={MyClass,__init__},          % Custom highlighting
  emphstyle=\ttb\color{deepred},    % Custom highlighting style
  stringstyle=\color{deepgreen},
  frame=tb,                         % Any extra options here
  showstringspaces=false            %
}

\lstdefinelanguage{docker}{
  keywords={FROM, RUN, COPY, ADD, ENTRYPOINT, CMD,  ENV, ARG, WORKDIR, EXPOSE, LABEL, USER, VOLUME, STOPSIGNAL, ONBUILD, MAINTAINER},
  keywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{docker-compose}{
  keywords={image, environment, ports, container_name, ports, volumes, links},
  keywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
\lstdefinelanguage{nginx}{
  keywords={server},
  keywordstyle=[2]\color{blue}\bfseries,
  keywordstyle=[3]\color{purple}\ttfamily,
  keywords=[2]{listen, location},
  keywords=[3]{proxy_pass, proxy_set_header},
  keywordstyle=\color{olive}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
\lstdefinelanguage{docker-compose-2}{
  keywords={version, services},
  keywordstyle=[2]\color{blue}\bfseries,
  keywords=[2]{image, environment, ports, container_name, ports, links, build,
  volumes, depends_on, restart},
  keywordstyle=\color{olive}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\makeindex

\definecolor{light-gray}{gray}{0.95}
\lstset{columns=fullflexible,basicstyle=\ttfamily}

\pgfplotsset{width=8cm,compat=1.9, xlabel={Year},
  ylabel={Number of documents}, xtick distance={2},
  ytick distance={2}, ymajorgrids=true,grid style=dashed,
  /pgf/number format/.cd,use comma,1000 sep={}}


\begin{document}

\input{titlepage.tex}
\input{preface.tex}
\thispagestyle{empty}
\newpage
\tableofcontents{}
\newpage
%\listoffigures
%\thispagestyle{empty}
%\newpage
%\rhead{}
%\lhead{}
%\renewcommand{\headrulewidth}{0pt}
%\renewcommand{\footrulewidth}{0pt}
\section{Introduction}
\subsection{Context}

Mental disorders are very common in our society. According to \cite{Bandelow2015}, almost 34\% of the population suffer from anxiety at least once in their lives. They are difficult to be diagnosed and properly treated. Most intervention programs do not last as much as they should and doctors have a very high workload, so patients need to wait for a long time before being advised by a doctor. In addition, although having a mental disease is very common, it is still a taboo subject whose stigma makes them even more difficult to be diagnosed and treated, as \cite{Davies2000} states.\\

In addition, people do not go to the doctor every time something happens, so there is not a continuous traceability of patients' health status. This causes a lot of relevant data not to be retrieved. This data could be suitable to perform more specific and personal medical analysis. Having a coach that regularly interacts with the person with a mental disorder as well as extracts data from his or her responses would take advantage of this information.


\subsection{Motivation}

Nowadays, technology is becoming increasingly integrated in our lives. Specifically, smartphones have became a daily basis used tool. People read the news, check the weather, chat with their relatives and friends, etc. using smartphones. Modern chat applications (such as \cite{Telegram}) allow people to create bots that can interact with them like if there was a person on the other side. These chatbots are increasingly becoming popular amongst people because they cover many functionalities, from tracking shipments to playing games and reminding stuff. Telegram bots do not require another app to be installed in the client's phone, so the client can save storage space.\\

As we previously discussed, mental disorders are taboo, so having a bot you could talk with about how was your day, feelings, etc. could lead to an easier way of diagnosing them because chat conversations are seen as ''natural'' by society. The conversational agent will ask the patient a batch of questions (previously defined by his/her doctor) and show the data to the specialist so that the diagnosis can be more precise.

\newpage

\subsection{Objectives}

\begin{itemize}
  \item \textbf{Main goal}: to develop a conversational-agent-as-a-sensor which will be able to interact with a person with a mental disorder in a natural way and ask questions defined by specialists.
  \item \textbf{Secondary goals}:
    \begin{itemize}
      \item To design a graphical web interface where doctors can consult their patient's responses.
      \item To design a flexible and scalable architecture to add functionality to the conversational agent.
      \item To design an architecture based on containers to host the different system modules.
      \item To implement a system that covers the previous goals.
      \item To test a beta version of the assistant in real people and analyse the retrieved data as well as target audience's feelings about it.
    \end{itemize}
\end{itemize}

\subsection{Structure}

The first chapter of this project offers an introduction to the context in which the main goal is intended to be developed as well as an analysis of related papers. This section is divided into four main categories (health application domains, conversational agents types, communication format and architecture) and a research about the popularity of chatbots.\\

The second one (\textbf{Methodology}) contains the proper requisites design, architecture, programming language and frameworks that are intended to be used in the system development, as well as its the most important modules and some code snippets to illustrate its functionality.\\

The third one, \textbf{Evaluation}, shows the results of the application testing amongst real people and the obtained results in an objective way.\\

The fourth chapter, \textbf{Discussion}, analyses the results obtained in the third chapter.\\

Finally, the last one, \textbf{Conclussions} analyses the initial objectives of the project and if they were achieved or not.



\newpage

\section{State of the art}

\subsection{Number of publications related to chatbots}

Several queries were performed on \textit{scopus.com} to check the number of articles per year related to chatbots and their applications in health. The obtained results were the following ones:

\begin{figure}[H]
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \begin{tikzpicture}
      \begin{axis}[title=\shortstack{chatbot OR "conversational agent"}, ytick distance={100}]
        \addplot table {data/chatbot_or_ca_query_results.dat};
      \end{axis}
    \end{tikzpicture}
  \end{subfigure}
  \hspace{3cm}
  \begin{subfigure}[t]{0.3\textwidth}
    \centering
    \begin{tikzpicture}
      \begin{axis}[title=\footnotesize{\shortstack{(chatbot OR "conversational agent")\\AND\\(coach OR counselor OR assistant)}},
                   ytick distance={15}]
        \addplot table {data/chatbot_or_ca_and_coach_or_counselor_or_assistant_query_results.dat};
      \end{axis}
    \end{tikzpicture}
  \end{subfigure}

  \vspace{0.5cm}

  \begin{subfigure}{\linewidth}
    \centering
    \begin{tikzpicture}
      \begin{axis}[title=\footnotesize{\shortstack{(chatbot OR "conversational agent")\\AND\\(coach OR counselor OR assistant)\\AND\\health}}, ytick distance={5}]
        \addplot table {data/chatbot_or_ca_and_coach_or_counselor_or_assistant_and_health_query_results.dat};
      \end{axis}
    \end{tikzpicture}
  \end{subfigure}
  \caption{Search results of different queries performed in \textit{scopus.com}}
\end{figure}

We can observe that, in the last 5 years, all of them show a considerable increasing number of articles and papers related to virtual assistants.


\subsection{Health application domains}

Chatbots can be applied to many health domains. For example, \cite{Alesanco2017185} proposes an agent that provides help to perform dermatological medicament prescriptions. \cite{BennetPraba20193470} takes care about nutrition by proposing a chatbot to motivate patients to maintain weight. Another example of conversational interface oriented to health is \cite{Falala-Sechet2019236}. This paper is about establishing a dialogue with patients to help them go through difficult situations that can affect their psychological status.\\

Chat agents can not only be classified according to the area they area applied to, but also according to the objective public. We can distinguish chatbots to help students learn, such as \cite{Lopez2008194} proposal, that offers a simulation of a real patient that presents several symptoms so that students have to interview it and make a diagnostic as a doctor would do in real life. Other interesting project is \cite{Shorey2019e14658}, that intends to improve communication between patients and hospital workers by making virtual patients simulate clinical scenarios so that undergraduates could practise with real situations instead of standard ones.\\

There are also chatbots aimed to help doctors do their work. For example, \cite{Ni201738} offers an agent that interviews sick people before the doctor does. Mandy elaborates a diagnostic based on several questions about patients symptoms and sends it to the doctor so that he can save that time. As professional treatments do not last as much, complements such as \cite{DAlfonso2017} are used. They offer a long-term treatment after the professional one so that the patient's progress is not lost. \\

Virtual agents can be also aimed to help patients. For example, \cite{Harilal2020349} is a counsellor that helps patients with depression by establishing empathetic conversations with them. \cite{Roca2020954} suggests an agent that offers help to people by reminding the intake of their medication, sending notifications to caregivers, providing summaries, etc.

Health coaches can be really helpful. For example, \cite{Breso2016297} proposes a platform to identify and provide early intervention for symptoms of depression and suicide. Its usability percentage was 75.7\% and its accuracy, 70.9\%. Another example is \cite{Hirano2017}, which offers preventive therapy for mental healthcare. The audience's mental health punctuation significantly improved after using the application. Moreover, the usage rate and the number of suggested actions carried out was high. That indicates that people found the app useful. By last, \cite{Ring2016} suggests an agent that responds to users' affective states during virtual therapy sessions. Facial expressions and voices are measured during the session. 70\% of users affirmed that they felt understood by the agent. 50\% of them stated that the agent evoked emotional responses in them during the interactions.

\newpage
\subsection{Conversational agents types and communication formats}

Virtual assistants can be classified attending to their main goal. Coaches help the user to get what he wants. For example, \cite{HUDLICKA2013160} presents a coach that assists people while trying to meditate by motivating them to do it. The paper's results showed that using the agent was more effective in helping users to establish a regular meditation habit. \cite{Guo2020} offers another coach that asseses users in their workouts to improve their postural hygiene by using wearables as sensors. Conversational agents can also be counselors (they help the user to identify and solve problems). The research carried out by \cite{Drislane2020158} proves that counselors can be really helpful when trying to reduce alcohol and drugs consumption amongst users. \cite{Yasavur2014381} suggests a virtual therapist that gives brief speech interventions (3-5 minutes) aimed to let a person's alcohol consumption up and make him or her be aware of the problem. \\

They can use different methods to communicate with their audience: text, voice or both. If we focus on speech-enabled conversational agents, we can distinguish \cite{Maharjan2019929}, which proposes a smart speaker that regularly asks its audience about their sleep quality, mood and physical activity. By analysing the given responses and their tone, volume and  intonation the agent is able to extract useful information useful for detecting markers of a possible mental ilness. In text-based chatbots, the user's input can be free (the agent will translate it to an ontology to understand it) or limited (a custom keyboard with fixed options will be shown or the agent will ask the user to enter a valid option). Finally, the most popular virtual assistants are multimodal (they both admit text and speech communication).

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{custom_keyboard.jpg}
  \caption{Example of a custom keyboard for a conversational agent}{Reprinted from https://core.telegram.org/bots}
\end{figure}


A review of each of the previous sections can be seen in \cite{Montenegro201956}.
\newpage
\subsection{Technology}

After performing some research, the following table was elaborated:

\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Platform} & \addstackgap{\textbf{\shortstack{Number of daily \\ active users}}} & \textbf{Free API to implement chatbots}  \\
    \hline
    \cite{FacebookMessenger} & 1.66 billion &  \greentick  \\
    \hline
    \cite{Whatsapp} & 1.5 billion & \redcross \\
    \hline
    \cite{WeChat} & 1.083 billion & \greentick  \\
    \hline
    \cite{Telegram} & 0.2 billion & \greentick \\
    \hline
    \cite{Kik} & 0.015 billion & \greentick \\
    \hline
    \cite{Discord} & 0.014 billion & \greentick \\
    \hline
    \cite{Slack} & 0.012 billion &  \greentick \\
    \hline
    \cite{Viber} & 0.008 billion &  \greentick \\
    \hline
    \cite{Line} & 0.00723 billion & \greentick  \\
    \hline
  \end{tabular}
  \caption{Comparison between different chat applications (2019)}
\end{table}


We can see that Whatsapp, which is the most used messaging app, has no free API to develop conversational agents (the one it has it oriented to business). As opposed, the rest of the widely used chat applications offer an API for programmers to build chatbots in an easy way. \\

A key aspect on social networks is the privacy they ensure. \cite{Kosinski5802} shows that Facbook's likes can be helpful to predict people's sensitive attributes such as age, gender or happiness. \cite{Rastogi17} affirms that Whatsapp's end-to-end encryption methods are not secure enough as metadata can reveal private information. On the other hand, \cite{Sutikno16} states that Telegram provides more privacy protection than other apps. One of its main features is that users can create and customize an username so that they don't have to exchange phone numbers to chat (such as in Whatsapp).


\newpage

\section{Methodology}

\subsection{Design}

\subsubsection{Requirements}
MoSCoW prioritization method \cite{moscow} will be used to classify the requirements of this project. MoSCoW is an acronym for ''\textbf{M}ust have, \textbf{S}hould have, \textbf{C}ould have and \textbf{W}on't have'', categories in which requirements are divided.
\begin{itemize}
  \item \emph{Must have} requirements. They are critical to the success of the project.
    \begin{itemize}
      \item The conversational agent must ask questions defined by doctors to the patients.
      \item The conversational agent must show a custom keyboard to the patient with the possible question answers.
      \item The application must allow doctors and patients enrollment and account deletion.
      \item The application must allow the doctors to download a file with their patients answers between two dates.
      \item The system must support modularity.
      \item The system must work using UTC timezone.
    \end{itemize}
  \item \emph{Should have} requirements. These are important requirements, but not necessary for  the system release.
    \begin{itemize}
      \item The system should be under a CC BY-NC-SA 4.0 \cite{CC} license.
      \item The application should allow the doctors to add, modify and delete questions and their respective answers.
      \item The application should allow the doctors to create public questions so that other doctors can assign them to their patients.
      \item The conversational agent should be able to ask questions following a configurable schedule.
      \item The application should show interactive charts to doctors with their patients data.
      \item The system should be able to show times according to Europe/Madrid timezone.
    \end{itemize}
  \item \emph{Could have} requirements. Desirable requirements that could improve user's experience or satisfaction. Will be included if there is time at the end of the development.
    \begin{itemize}
      \item The system could implement a numeric priority to manage the order in which questions are asked.
      \item The system could allow the doctors to configure the frequency of each question (only once, daily, weekly, monthly, etc.).
      \item The system could be translated to other languages.
      \item The application could support password change functionality for doctors.
      \item The application could support two factor authentication for doctors.
      \item The conversational agent could support groups.
      \item The system could allow doctors and patients to delete all their data from the system.
      \item The agent could offer an option to the patients to view and modify their profile data.
      \item The applications could allow doctors to assign a question to all their patients when creating it.
      \item The system could support more timezones.
    \end{itemize}
  \item \emph{Won't have} requirements. They are inappropiate or the least important ones, so they are not included in the project.
    \begin{itemize}
      \item The application won't be cross-platform.
      \item The system won't share the retrieved data with third parties.
    \end{itemize}
\end{itemize}
\newpage
\subsubsection{Architecture}

The proposed system will implement the following architecture:
\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=1.35\linewidth, angle=-270]{architecture.pdf}
    }
    \caption{System architecture. Created using \emph{diagrams.net} \protect\cite{drawio}}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=0.95\linewidth]{conv_agent.pdf}
    }
    \caption{System architecture (conversational agent and databases)}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=0.98\linewidth]{web_int.pdf}
    }
    \caption{System architecture (web interface agent and databases)}
\end{figure}


Italic text and dashed lines represent optional features (should and could requirements), whereas continuous  lines refer to mandatory ones (must).

The architecture is divided into three main modules: conversational agent (used by patients), databases and web interface (used by doctors).

HOW-R-U is structured in four main databases. Users database contains doctors and patients information and their corresponding configurations. Patient objects stored in this database have properties such as name, username, chat id, gender, language, schedule and profile picture, whereas Doctor entries contain attributes like username, password, if the doctor is a data analyst and session information. Questions database contain Question entries, consisting on question text, possible responses, question language, priority, frequency and author. Pending questions database holds entries that link a doctor, a question and a patient. Moreover, they also include a flag that determines if the question (assigned by the corresponding doctor) is being answering right now by the related patient. Finally, Answered questions database contains entries that also link a patient, a doctor and a question. They include two more properties: response given by the patient and answer date.

The conversational agent offers the patient three submodules, triggered by different events. The first one is the accounts manager, including three components. The first one is the Account Creator, in which the conversational agent will ask the user the language in which the interface will be shown, his/her name, gender, profile picture and schedule for questions . This event is triggered when the patient interacts with the agent for the first time. The second one is the Account viewer, which shows the patient all the details about his/her account. Finally, the Account Remover allows the patient to completely delete all his/her data from the system in an unrecoverable way. These two last components are triggered by an specific command sent by the patient.

The second module is the configurator. It is also triggered by a command. This interface shows a menu with the available options: change name, gender, language, profile picture or schedule. All these actions have a fallback command to cancel the current operation. When an operation is completed, the corresponding data is retrieved, modified or deleted from the Users database.

Finally, the last module (conversation generator). This flow is triggered when the schedule time comes. The system will check the pending questions database to check if the user has to answer at least a question today. If the previous condition is fullfilled, the question will be prompted, along with a custom keyboard showing the different answers. Everytime a question is answered, an AnsweredQuestion entry containing the patient id, question id, doctor id and answer date is created and stored in the corresponding database. When all the pending questions have been answered, this flow terminates and the agent thanks the user. If there are no questions to ask, the chatbot will inform the patient.

Last but not least, the web interface interface contains four submodules. The first one is the doctors manager, which permits accounts creation, password change, authentication and deletion. The second one is the patient manager, which lets doctors to assign and unassign patients to its account as well as assign or unassign questions to them. The third one is the questions manager, which allows doctors to create, modify and delete questions. Finally, the data manager offers doctors the possibility to observe charts created with the patient's answers along the time or download a file containing all these data between two dates.




\subsection{Implementation}

The main software that will be used to implement this project will be the following:
\begin{itemize}
  \item Python 3.6.10 \cite{python} as the main programming language for both the web interface and the agent. The following libraries will also be used:
  \begin{itemize}
    \item \emph{python-telegram-bot} to develop the conversational agent.
    \item \emph{ujson} to create and read JSON files in a fast way.
    \item \emph{pytz} for timezone management.
    \item \emph{psycopg2} to connect python with the database management system.
    \item \emph{pillow} to work with images.
  \end{itemize}
  \item Django 3.0.6 \cite{django} as the framework to develop the web interface.
  \item PostgreSQL 12.3 \cite{postgres} as the database management system.
  \item Nginx 1.17 \cite{nginx} as the reverse proxy to redirect the requests from users to the web interface.
  \item Docker 19.03.6 \cite{docker} as the platform where the developing environment is built on.
  \item Telegram \cite{Telegram} as the platform where the conversational agent will offer its services to the patients.
\end{itemize}

HOW-R-U will be structured in the following way:

\begin{figure}[H]
  \centering
    \includegraphics[width=\textwidth]{repo_structure.pdf}
    \caption{HOW-R-U modules structure. Created using \emph{diagrams.net} \protect\cite{drawio}}
\end{figure}

In addition, the system will be prepared to be compatible with Docker in order to deploy a HOW-R-U development environment by including a folder with \emph{Dockerfiles}, \emph{docker-compose} and configuration files.
\newpage
\subsection{Submodules: models and helpers}

Models will be a submodule shared by both the web interface and the conversational agent. It will contain the definition of the different system classes. Django ORM will be used in both of them to simplify database and model operations. To add django to the conversational agent, a custom \emph{manage.py} with the system settings (such as database details and models specification) has been created:

  \begin{python}[caption={Custom \emph{manage.py} file to use Django ORM in the agent. Based in \href{https://stackoverflow.com/questions/45595750/use-django-orm-outside-of-django}{https://stackoverflow.com/questions/45595750/use-django-orm-outside-of-django}}, captionpos=b]
  #!/usr/bin/env python
  import json
  import sys
  import django

  ROUTES_FILE_PATH = '/etc/howru/cfg/routes.json'
  with open(ROUTES_FILE_PATH) as routes_file:
    json_file = json.load(routes_file)
    NAME = json_file['name']
    USER = json_file['user']
    PWD = json_file['password']
    HOST = json_file['host']
    PORT = json_file['port']

  DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': NAME,
        'USER': USER,
        'PASSWORD': PWD,
        'HOST': HOST,
        'PORT': PORT,
    }
  }

  INSTALLED_APPS = [
    'howru_models',
    'django.contrib.contenttypes',
    'django.contrib.auth'
  ]
  from django.conf import settings
  settings.configure(
    DATABASES=DATABASES,
    INSTALLED_APPS=INSTALLED_APPS,
    USE_TZ=True
  )
  django.setup()

  \end{python}

HOW-R-U models will follow the class diagram below:

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{class_diagram.pdf}
    }
    \caption{System class diagram. Generated by \emph{django-extensions} \protect\cite{django}}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{class_diagram_zoom.pdf}
    }
    \caption{System class diagram (HOW-R-U classes)}
\end{figure}

As we can see, there are six main models in \emph{howru\_models}: Doctor, Patient, Question, Response, Pending Question and Answered Question (both inherit from JournalEntry, an abstract model). A Doctor has a one-to-one relationship with an user, a \emph{Django} pre-defined model which takes care of all authentication, permissions, logs and session logic.

The other submodule, helpers, allows coding and decoding flag emojis from country codes and managing time conversions between UTC (the main time standard in the world) and the timezone in which the system is configured.

\subsection{Conversational agent}


The conversational agent module contains 7 submodules: \emph{config}, where the secret token is stored and messages, a file which contains all the messages the bot can send in English and Spanish. The bot secret token is a string which contains an unique identifier that links a Telegram bot user with the code it will run. This token is given by \emph{@BotFather}, a bot used to create bots. More information about the bot creation process will be explained in the \hyperref[sec:env_setup]{environment setup section}.

The next submodule, handlers, defines the bot behaviour according to certain events, like sending the \emph{/start} command (the first one that is sent when an user interacts with a bot), sending the {\emph{/config}} one, etc. There are three main handlers:
\begin{itemize}
  \item Start handler: asks the patient for his/her name, gender, language, schedule, and profile picture.
  \item Config handler: manages the configurator module, as well as the account viewer and remover.
  \item Questions handler: handles the questions prompting and answering.
\end{itemize}

Handlers are triggered by a certain event, catched by filters. For example, to catch the \emph{/start} message sent by the patient, the implemented procedure is the following:

\begin{python}[caption={Patient start callback}, captionpos=b]
GENDER, PICTURE, LANGUAGE, SCHEDULE = range(4)
@send_typing_action
def start(update, context):
    """
    Shows welcome message and asks for language
    """
    # Check that user is not registered
    try:
        patient = Patient.objects.get(identifier=update.message.from_user.id)
        logger.info(
            f'User {update.message.from_user.username} tried to register again.')
        update.message.reply_text(text=messages[patient.language]['already_exists'])
        return ConversationHandler.END
    except Patient.DoesNotExist:
        # The user should not exist in DB
        context.user_data['patient'] = Patient(name=update.message.from_user.first_name, identifier=str(update.message.from_user.id), username=update.message.from_user.username)
        logger.info(f'User {update.message.from_user.username} started a new conversation')
        update.message.reply_text(text=f'Hi {update.message.from_user.first_name}. Welcome to HOW-R-U psychologist bot.\nHola {update.message.from_user.first_name}. Bienvenido al bot psicologo HOW-R-U')
        update.message.reply_text(text=f'Please select a language:\nElija un idioma por favor:', reply_markup=keyboards.language_keyboard)
    return LANGUAGE

  <--------------->

  start_handler = ConversationHandler(
      entry_points=[CommandHandler('start', start)],
      states={
          LANGUAGE: [MessageHandler(Filters.regex(f'^({Flag.flag("es")}|{Flag.flag("gb")})$\dollar$'), language)],
          GENDER: [MessageHandler(Filters.regex('^(Male|Female|Other|Masculino|Femenino|Otro)$\dollar$'), gender)],
          PICTURE: [MessageHandler(Filters.photo, picture), CommandHandler('skip', skip_picture)],
          SCHEDULE: [MessageHandler(Filters.regex('^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$\dollar$'), schedule)]
      },
      fallbacks=[],
      name="starter"
  )
\end{python}

We can see how the command \emph{start} is the entry point of the start handler. When the event is detected, \textbf{start} callback is invoked. This callback ensures that the patient is not already registered (if so, informs the user and finishes the conversation) and prompts a welcome message as well as a custom keyboard with flags, one for each available language. Then, it returns \emph{LANGUAGE}, an state that shows that the agent is waiting for language selection. Start callback creates a Patient object whose data will be filled in the following procedures and stores it in context user data, a reserved storage space for each user. After language, profile picture, gender and schedule are asked, the agent finally saves the entry in the database in the following way:

\begin{python}[caption={Patient saver callback}, captionpos=b]
  @send_typing_action
  def finish(update, context):
      """
      Saves patient in DB, assigns him/her to data_analyst, creates PendingQuestion entries for assigned_to_all questions and finally creates the user's PendingQuestionJob
      """
      patient = context.user_data['patient']
      patient.save()
      # Add patient to data analysts and assigned_to_all questions
      try:
          data_analysts = Doctor.objects.filter(is_analyst=True)
          for doctor in data_analysts:
              patient.assigned_doctors.add(doctor)
              patient.save()
              assigned_to_all = doctor.assigned_questions.filter(assigned_to_all=True)
              for question in assigned_to_all:
                  pending_question = PendingQuestion(doctor=doctor, question=question, patient=patient, answering=False)
                  pending_question.save()
          logger.info("Patient %s assigned to data_analysts", patient.username)
      except:
          logger.exception("Exception while adding patient %s to data_analysts.", patient.username)
      update.message.reply_text(messages[patient.language]['registration_ok'])
      logger.info(f'Creating pending_questions job for user {update.message.from_user.username}')
      PendingQuestionJob(context, patient)
      return ConversationHandler.END
\end{python}

The database entry is created simply with the command \emph{patient.save()} thanks to \emph{django} ORM. After saving the patient for the first time, we need to assign it to all data analysts in the system and assign him/her the questions the analyst have created and configured as assigned to all. Finally, a \emph{job} is created so that assigned questions to the patient are sent. When these procedures are completed, the callback returns \emph{ConversationHandler.END}, indicating that the conversation has ended.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{start.png}
  \caption{Agent showing welcome message and asking for language selection}
\end{figure}

The \emph{config handler} is invoked when the \emph{/config} command is sent. This command appears in a pop-up menu next to the text input. The configurator callbacks are pretty similar between them. There are two types of them: \emph{ask\_for\_$<$property$>$} and \emph{process\_$<$property$>$}. The first ones send a message to the patients with the old value of the property they want to change and ask them to send the new value. The second ones update the patient's database entry with the new value. For example, the schedule changer is implemented as follows:

\begin{python}[caption={Name changer configurator callbacks}, captionpos=b]
  @send_typing_action
  def ask_change_language(update, context):
      """
      Sends old language to the user and asks for the new one
      """
      patient = context.user_data['patient']
      logger.info(f'User {update.message.from_user.username} asked to change language')
      update.message.reply_text(messages[patient.language]['current_language'] + patient.language)
      update.message.reply_text(messages[patient.language]['change_language'], reply_markup=keyboards.language_keyboard)
      return PROCESS_LANGUAGE

  @send_typing_action
  def process_language(update, context):
      """
      Saves the new language
      """
      patient = context.user_data['patient']
      patient.language = Flag.unflag(update.message.text)
      patient.save(update_fields=['language'])
      logger.info(f'User {update.message.from_user.username} changed language to {patient.language}')
      update.message.reply_text(messages[patient.language]['language_updated'])
      return config_menu(update, context)
  <------------------->
  config_handler = ConversationHandler(
      entry_points=[CommandHandler('config', config)],
      states={
          CHOOSING: [
                     MessageHandler(Filters.regex('^(Cambiar nombre|Change name)$\dollar$'), ask_change_name),
                     MessageHandler(Filters.regex(f'^(Cambiar idioma|Change language)$\dollar$'), ask_change_language),
                     .....
                     ],
          PROCESS_NAME: [MessageHandler(~is_answering_filter & ~Filters.command, process_name)],
          PROCESS_LANGUAGE: [MessageHandler(Filters.regex(f'^({Flag.flag("es")}|{Flag.flag("gb")})$\dollar$'),
                                            process_language)],
          .....
      },
      fallbacks=[CommandHandler('cancel', cancel),
                 CommandHandler('exit', _exit)],
      name="configurator"
  )

\end{python}

The name changer needs a specific filter. As the desired input format is text, we need to distinguish between text and a command (started by \emph{/}). To do so, the command filter is negated (\emph{\~{}Filters.command}). In addition, the agent must distinguish when the name is being changed (a string is expected) and a question is being answered (a string is also being expected). To do so, a custom filter has been developed. This filter matches when a question is being answered at the moment (\emph{~is\_answering\_filter}). Finally, these two filters are combined using an \emph{AND} logic operation. Last but not least, \emph{/cancel} allows the user to cancel the current operation and go back to the configurator menu and \emph{/exit} closes the configurator.

\begin{python}[caption={IsAnswering filter}, captionpos=b]
class IsAnsweringFilter(BaseFilter):
    def filter(self, message):
        """
        Checks if the patient is answering a question
        :return: True if a question is being answered, False otherwise
        """
        patient = Patient.objects.get(identifier=message.from_user.id)
        return patient.pendingquestion_set.all().filter(answering=True)
  # Initialize the class.
  is_answering_filter = IsAnsweringFilter()
\end{python}

Finally, the questions handlers contains just one callback and no states. The callback is invoked when the user sends a message that is not a command and a question is being answered at the moment.

\begin{python}[caption={Questions handler}, captionpos=b]
@send_typing_action
def answer_question(update, context):
    """
    Prompts user's question by querying PendingQuestion DB.
    Creates an AsweredQuestion object.
    """
    user = update.message.from_user
    response = update.message.text
    # Get question that is being answered from DB:
    try:
        question_task = _get_pending_question_task(str(user.id))
    except PendingQuestion.DoesNotExist:
        logger.info(
            f'User {user.username} id {user.id} wrote {response} while there was no question to answer')
        update.message.reply_text("Unrecognized command\nComando no reconocido", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END
    logger.info(f'User {user.username} id {user.id} answered "{response}" to question "{question_task.question}"')
    # Create answered question entry
    answered_question = AnsweredQuestion(patient_id=user.id, doctor=question_task.doctor, answer_date=datetime.now(pytz.timezone('Europe/Madrid')), response=response, question=question_task.question)
    answered_question.save()
    # Set answering to false
    question_task.answering = False
    question_task.save()
    return ConversationHandler.END

def _get_pending_question_task(user_id):
    """
    Obtains the question that the user is answering
    """
    return PendingQuestion.objects.get(patient_id=user_id, answering=True)


question_handler = ConversationHandler(
    entry_points=[MessageHandler(~Filters.command & is_answering_filter, answer_question)],
    states={},
    fallbacks=[],
    name="questions_handler"
)

\end{python}

When the user sends an answer, this callback retrieves the pending question that is being answered and creates the corresponding AnsweredQuestion entry. After that, sets the answering flag to false in the PendingQuestion object.

\begin{figure}[H]
  \centering
    \includegraphics[width=\textwidth]{bot_answering.png}
  \caption{HOW-R-U converstional agent asking a question to a patient}
\end{figure}

\begin{figure}[H]
  \centering
    \includegraphics[width=\textwidth]{config_menu.png}
  \caption{Configurator menu}
\end{figure}

The next conversational agent module is \emph{jobs}. Jobs are tasks that run a callback with a fixed frequency (daily, monthly, hourly, etc.). In this project, jobs are used to ask the patient the corresponding questions when the schedule time arrives.

\begin{python}[caption={PendingQuestion job}, captionpos=b]
class PendingQuestionJob(object):
  def __init__(self, context, patient):
      self.patient = patient
      self._create_job(context)

  def job_callback(self, context):
      """
      Prompts PendingQuestions to the user.
      """
      pending_questions = self._get_pending_questions()
      for task in pending_questions:
          if not self.is_question_answered(task):
              question = task.question
              task.answering = True
              task.save()
              context.bot.send_message(chat_id=self.patient.identifier, text=question.text, reply_markup=keyboards.get_custom_keyboard(question.responses))
              while not self.is_question_answered(task):
                  time.sleep(0.5)
      message = messages[self.patient.language]['finish_answering'] if self.answered_questions_today() else messages[self.patient.language]['no_questions']
      logger.info(f'User {self.patient.username} answered all the questions')
      context.bot.send_message(chat_id=self.patient.identifier, text=message, reply_markup=ReplyKeyboardRemove())
      time.sleep(0.1)
      if was_configurator_running(self.patient.identifier, context):
          logger.info(f'Reopening configurator for user {self.patient.username} id {self.patient.identifier}')
          context.bot.send_message(chat_id=self.patient.identifier,  text=messages[self.patient.language]['select_config'], reply_markup=keyboards.config_keyboard[self.patient.language])

  def _create_job(self, context):
      context.job_queue.run_daily(callback=self.job_callback, time=self.patient.schedule, name=f'{self.patient.identifier}_pending_questions_job')
\end{python}

When a PendingQuestionJob instance is created, a daily job is established (running at the patient schedule time). The job callback queries PendingQuestions database and select the ones that should be answered (depending on their frequency and last answer) and orders it by priority, so that questions with lower priority are asked first. Then, it creates a custom keyboard with one button per response and sends the patient the question text as a message. Finally, when all questions have been answered, the job informs the user and opens the configurator if it was open. Sleep times have been added to make the process smoother.


Finally, \emph{pics} folder is a temporary directory where profile pictures are stored and then deleted after encoding them in base-64 to be uploaded to the database. \emph{log} contains a basic logging utility that shows useful information, such as time, process and thread. Finally, \emph{src} contains the main file which starts the bot service:

\begin{python}[caption={Bot file, the one that starts the service}, captionpos=b]
def main():
    logger.info("Started HOW-R-U psychologist")
    # Initialize bot
    updater = Updater(token=bot_config.TOKEN, use_context=True)
    dispatcher = updater.dispatcher
    handlers = [start_handler, config_handler, question_handler]
    # Add handlers to dispatcher
    for handler in handlers:
        dispatcher.add_handler(handler)
    # Add error callback
    dispatcher.add_error_handler(error_callback)
    # Start bot service
    updater.start_polling()
    updater.idle()

if __name__ == "__main__":
    main()
\end{python}
\newpage
\subsection{Web interface}

The web interface is based on \cite{appseed}.

HOW-R-U web interface is is a \emph{django} project structured into four main applications: app (the homepage), questions manager, patients manager and authentication (create users, modify passwords and login/logout functionalities).

The first page that is shown to the user is the login interface, with text boxes for user and password fields. The user can also register in the system with a button.

\begin{figure}[H]
  \begin{subfigure}[t]{0.4\textwidth}
    \centering
    \includegraphics[width=\textwidth]{login.png}
  \end{subfigure}
  \hspace{3cm}
  \begin{subfigure}[t]{0.4\textwidth}
    \centering
    \includegraphics[width=\textwidth]{register.png}
  \end{subfigure}
  \caption{Login and register pages}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{register_error.png}
    \caption{Register form validations}
\end{figure}

The register form has several validations, such as password length, strength, etc. These validators are provided by \emph{django auth} application. The user can also choose to be a \emph{data analyst}, a special user that does not have to add patients to his/her account manually. Everytime a patient registers into the system is automatically assigned to all data analysts. This feature is useful to collect statistics.

\begin{python}[caption={Method to register an user in the system}, captionpos=b]
  def register_user(request):
    if request.method == "POST":
        form = SignUpForm(request.POST)
        if form.is_valid():
            form.save()
            # If the doctor is an analyst, assign him/her all the patients in the system
            analyst = form.cleaned_data['is_analyst']
            form.instance.doctor.is_analyst = analyst
            if analyst:
                form.instance.doctor.patient_set.set(Patient.objects.all())
            form.save()
            username = form.cleaned_data.get("username")
            raw_password = form.cleaned_data.get("password1")
            user = authenticate(username=username, password=raw_password)
            login(request, user)
            return redirect("/")
    else:
        form = SignUpForm()
    return render(request, "accounts/register.html", {"form": form})
\end{python}

After logging in to the system, the homepage is shown. It is divided into three main sections. The first one shows statistics about the logged in doctor: the number of associated patients, submitted questions and total answers. Below, there is a panel that shows the percentage of answers per hour and patients per gender. Finally, a top 5 with the patients that have answered the most is exhibited.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{homepage.png}
    \caption{HOW-R-U homepage}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=0.8\linewidth]{homepage_1.png}
    }
    \caption{HOW-R-U homepage (doctor statistics)}
\end{figure}


\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=0.8\linewidth]{homepage_2.png}
    }
    \caption{HOW-R-U homepage (response statistics)}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{homepage_3.png}
    }
    \caption{HOW-R-U homepage (top 5)}
\end{figure}
\newpage
\begin{python}[caption={Method to show the main homepage components}, captionpos=b]
  @login_required(login_url="/login/")
  def index(request):
      """
      Shows the index page, including global parameters (top patients, number of associated patients, answers, gender and time percentages, etc.)
      """
      doctor = request.user.doctor
      top_patients = get_top_patients(doctor)
      doctor_patients = doctor.patient_set
      number_associated_patients = doctor_patients.count()
      submitted_questions = Question.objects.filter(creator=doctor).count()
      total_answers = get_total_answers(doctor)
      male_percentage, female_percentage, other_percentage = get_gender_stats(doctor, number_associated_patients)
      answers_per_hour = get_answers_per_hour(doctor)
      context = {
          "top_patients": top_patients,
          "number_associated_patients": number_associated_patients,
          "submitted_questions": submitted_questions,
          "total_answers": total_answers,
          "male_percentage": male_percentage,
          "female_percentage": female_percentage,
          "other_percentage": other_percentage,
          "answers_per_hour": answers_per_hour
      }
      return render(request, "index.html", context)
\end{python}

In the sidebar the user has access to the main components of the system. The first one is the \textbf{questions manager}. When the doctor clics on it, a dropdown is opened, letting choose public or private questions.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3  \textwidth]{questions_dropdown.png}
    \caption{Questions manager dropdown}
\end{figure}

The public question interface shows a paginated table containing all the questions that have been incorporated to the system and marked as public. Moreover, there is a search bar and a button to add a public question to the user's questions list, so that he/she can assign it to the patients. When the user searches a question, the search term is encoded in the URL (GET request). The system has to build custom URLs when a search is being performed and the user clics the next page. This is achieved thanks to the code below.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{public_questions.png}
    \caption{Public questions page}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{public_questions_1.png}
    }
    \caption{Public questions page (question created by other user)}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{public_questions_2.png}
    }
    \caption{Public questions page (question created by the current user)}
\end{figure}

\begin{python}[caption={Method to show public questions page}, captionpos=b]
  @login_required(login_url="/login/")
  def public_questions(request):
      """
      Shows public questions inside the system.
      """
      if 'search' in request.GET:
          term = request.GET['search']
          all_questions = Question.objects.filter(text__icontains=term, public=True).order_by('text')
      else:
          all_questions = Question.objects.filter(public=True).order_by('text')
      page = request.GET.get('page', 1)
      paginator = Paginator(all_questions, settings.PAGE_SIZE)
      try:
          questions = paginator.page(page)
      except PageNotAnInteger:
          questions = paginator.page(1)
      except EmptyPage:
          questions = paginator.page(paginator.num_pages)
      request.session['public_questions_page'] = page
      return render(request, 'questions_manager/public_questions.html', context={
          'questions': questions,
          'success_msg': request.session.pop('message', None)
      })
\end{python}

The HTML page (template) to show the public questions is built following the pseudo-code below:
\begin{lstlisting}[language=html, caption={Pseudo-code to generate public questions template page}, captionpos=b]
<table>
<thead>
<tr>
<th>Question text</th>
<th>Possible responses</th>
<th>Assigned to all</th>
<th>Frequency</th>
<th>Priority</th>
<th>Creator</th>
<th>Language</th>
<th>Actions</th>
</tr>
</thead>
{% for question in questions %}
    <tr>
        <td>
          {{ question.text }}
        </td>
        <td>
          {% for response in question.responses %}
          {{response}} <br>
          {% endfor %}
        </td>
        <td>
          {% if question.assigned_to_all %}
          check_icon
          {% else %}
          cross_icon
          {% endif %}
        </td>
        <td>
          {{ question.get_frequency_display }}
        </td>
        <td>
          {{ question.priority }}
        </td>
        <td>
          {{ question.creator.user.username }}
          {% if question.creator.user.username == request.user.username %}
          (You)
          {% endif %}
        </td>
        <td>
          {% if question.language == "ES" %}
          spanish_flag
          {% else %}
          england_flag
          {% endif %}
        </td>
        <td>
          {% if question in request.user.doctor.assigned_questions.all %}
          added_button
          {% else %}
          add_button
          {%endif%}
        </td>
    </tr>
    {% endfor %}
    </tbody>
</table>
\end{lstlisting}

\begin{python}[caption={Pagination code snippets. Retrieved from \href{https://medium.com/@sumitlni/paginate-properly-please-93e7ca776432}{https://medium.com/@sumitlni/paginate-properly-please-93e7ca776432}}, captionpos=b]
@register.filter
def paginate(paginator, current):
  num_pages = settings.PAGE_SIZE
  if paginator.num_pages > 2 * num_pages:
      start = max(1, current - num_pages)
      end = min(paginator.num_pages, current + num_pages)
      if end < start + 2 * num_pages:
          end = start + 2 * num_pages
      elif start > end - 2 * num_pages:
          start = end - 2 * num_pages
      if start < 1:
          end -= start
          start = 1
      elif end > paginator.num_pages:
          start -= (end - paginator.num_pages)
          end = paginator.num_pages
      pages = [page for page in range(start, end + 1)]
      return pages[:(2 * num_pages + 1)]
  return paginator.page_range

@register.simple_tag
def get_url(request, field, value):
    query_string = request.GET.copy()
    query_string[field] = value
    return query_string.urlencode()
\end{python}



The user's questions page is similar to the public ones. The main differences is that there are three new buttons: modify, delete and create new questions.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{my_questions.png}
    \caption{User's questions page}
\end{figure}


\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{my_questions_1.png}
    }
    \caption{User's questions page (example)}
\end{figure}

The create and modify interfaces show a form with help messages to build or edit them. The main validations in these ones are that all fields are required and there should be at least two responses per question. Questions creator and modifier forms are created by inheriting from \emph{django.forms}.

\begin{figure}[H]
  \centering
    \includegraphics[width=\textwidth]{questions_modifier.png}
  \caption{Questions creator and modifier}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{questions_modifier_1.png}
    }
    \caption{Questions creator and modifier fields (1/2)}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{questions_modifier_2.png}
    }
    \caption{Questions creator and modifier fields (2/2)}
\end{figure}


The available fields are the following ones:
\begin{itemize}
  \item \textbf{Question text}: what should be asked to the patient.
  \item \textbf{Responses} (one per line). They should be ordered from bad to good so that plots are properly rendered.
  \item \textbf{Privacy} (public or private). Wether other users can add this question to their profile.
  \item \textbf{Language} (English or Spanish).
  \item \textbf{Frequency} (once, daily, weekly or mothly). How often the question should be asked.
  \item \textbf{Priority} ($[1,\infty[$). Order in which the question should be asked. Lower priority questions will be asked first.
  \item \textbf{Assigned to all} (yes or no). Wether the question should be automatically assigned to all the user's patients.
\end{itemize}

\begin{python}[caption={Form to create or modify questions}, captionpos=b]
class QuestionForm(ModelForm):
    privacy = forms.CharField()
    to_all = forms.CharField()
    responses_field = forms.CharField()
    class Meta:
        model = Question
        fields = ["text", "public", "language", "priority", "frequency"]
    def clean(self):
        cd = self.cleaned_data
        clean_responses = cd.get("responses_field").replace('\r', '')
        response_list = list()
        for response in clean_responses.split('\n'):
            if response:
                clean_response = response.strip()
                if clean_response:
                    response_list.append(response)
        if len(response_list) < 2:
            raise ValidationError("You must specify at least two possible responses")
        self.cleaned_data['responses'] = response_list
        privacy = cd.get("privacy")
        self.cleaned_data['public'] = privacy == "Public"
        self.cleaned_data['assigned_to_all'] = self.cleaned_data['to_all'] == "yes"
\end{python}

As \emph{public} and \emph{assigned to all} are boolean in the models but text in the views, we have to manually analyse the data retrieved from the form. The number of answers is also validated in the \emph{clean} method.

Finally, the questions deletion page consists on a view showing a confirmation message and two buttons, \textbf{confirm} and \textbf{back}.
\\

The patients manager consists on another paginated table that shows all the patients associated to the doctor. There is also a search bar, a button to add new patients and three buttons to manage each patient: view data, assign questions and delete patient from the doctor's page. Finally, there is also a export button to dump responses to a CSV file.

\begin{figure}[H]
  \centering
    \includegraphics[width=\textwidth]{patients_manager.png}
  \caption{Patients manager}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=0.8\linewidth]{patients_manager_1.png}
    }
    \caption{Patients manager (example)}
\end{figure}

The button to add new patients redirects the user to a page so that he/she can enter the patient's Telegram username. Once done, the patient will be shown in the main view.

The assign question page consists of a paginated table showing the doctor's questions list. The assignment/unassignment is performed with a button at the end of each row. These processes consist on creating or deleting a \emph{PendingQuestion} object linking doctor, patient and question.

\begin{figure}[H]
  \centering
    \includegraphics[width=\textwidth]{assign_questions.png}
  \caption{Patients manager assign questions page}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{assign_questions_1.png}
    }
    \caption{Patients manager assign questions page (unassigned question)}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{assign_questions_2.png}
    }
    \caption{Patients manager assign questions page (assigned question)}
\end{figure}

The patients deletion button removes it from the doctor's associated patients list. After that, it can be added again. By deleting a patient, all the related \emph{PendingQuestion} are also deleted so that questions assigned to that user by the doctor that deletes it are asked no more. However, answers are preserved so that data can be analysed in the future if it is added again. If the users wants to delete this data, he/she must delete the patient account.
\\


The export page offers a form to select patients, start date and end date. When done, it generates a CSV file with four columns: patient username, question, answer and date.

\begin{figure}[H]
  \centering
    \includegraphics[width=\textwidth]{export.png}
  \caption{Export page}
\end{figure}

\begin{table}[]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{@{}cccc@{}}
\toprule
\textbf{Patient username} & \textbf{Question}                                                                                      & \textbf{Answer}   & \textbf{Date}       \\ \midrule
robert\_garfield          & How do you feel today?                                                                                 & Tired             & 2020-04-01 04:12:20 \\
robert\_garfield          & How do you feel today?                                                                                 & Sad               & 2020-04-02 05:24:20 \\
robert\_garfield          & How long have you slept today?                                                                         & 0-2 hours         & 2020-04-01 12:56:20 \\
robert\_garfield          & How long have you slept today?                                                                         & 4-6 hours         & 2020-04-02 11:28:20 \\
robert\_garfield          & Do you feel sad and cry easily?                                                                        & Yes               & 2020-04-01 14:22:21 \\
robert\_garfield          & Do you feel sad and cry easily?                                                                        & No                & 2020-04-02 06:31:21 \\
oliver\_morton            & How do you feel today?                                                                                 & Very happy        & 2020-04-01 01:45:19 \\
oliver\_morton            & How do you feel today?                                                                                 & Happy             & 2020-04-02 02:59:19 \\
oliver\_morton            & How long have you slept today?                                                                         & More than 8 hours & 2020-04-01 20:51:20 \\
oliver\_morton            & How long have you slept today?                                                                         & 2-4 hours         & 2020-04-01 22:24:20 \\
oliver\_morton            & Do you feel sad and cry easily?                                                                        & No                & 2020-04-01 07:47:20 \\
oliver\_morton            & Do you feel sad and cry easily?                                                                        & Yes               & 2020-04-02 17:26:20 \\
oliver\_morton            & \begin{tabular}[c]{@{}c@{}}Have you noticed an appetite \\ decreasement in the last week?\end{tabular} & Yes               & 2020-04-01 21:41:20 \\
oliver\_morton            & \begin{tabular}[c]{@{}c@{}}Have you noticed an appetite \\ decreasement in the last week?\end{tabular} & Yes               & 2020-04-08 21:09:20 \\ \bottomrule
\end{tabular}%
}
\caption{Example data generated with the \emph{Export} feature}
\end{table}

Finally, the\emph{View Data} section generates plots showing patient's answers. There are two plots per question: a line chart showing the different answers amongst time and a pie one manifesting the number of times each answer has been replied. Both charts are interactive so that when the doctor hovers the mouse on them, a box is shown specifying more data about the selected section. These view is also paginated and includes a search bar to filter questions.

\begin{figure}[H]
  \centering
    \includegraphics[width=\textwidth]{view_data.png}
  \caption{View data page}
\end{figure}
\vspace{5cm}
\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=\linewidth]{view_data_1.png}
    }
    \caption{View data page (line chart)}
\end{figure}

\begin{figure}[H]
    \makebox[\linewidth]{
        \includegraphics[width=0.5\linewidth]{view_data_2.png}
    }
    \caption{View data page (pie chart)}
\end{figure}

The last system view is the account manager. It is a dropdown that lets the user change the password, delete the account or log out.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{account_dropdown.png}
    \caption{Account manager dropdown}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{change_pwd.png}
    \caption{Change password page}
\end{figure}

\begin{python}[caption={Method to change user's password}, captionpos=b]
@login_required(login_url="/login/")
def change_password(request):
    """
    Allows an user to change his/her password
    """
    success = False
    if request.method == 'POST':
        form = PasswordChangeForm(request.user, request.POST)
        if form.is_valid():
            user = form.save()
            update_session_auth_hash(request, user)  # Important!
            success = True
    else:
        form = PasswordChangeForm(request.user)
    return render(request, 'change_password.html', {
        'form': form,
        'success': success
    })
\end{python}


\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{delete_account.png}
    \caption{Delete account page}
\end{figure}


\begin{python}[caption={Method to delete an account}, captionpos=b]
@login_required(login_url="/login/")
def delete_account(request):
    """
    Deletes a doctor from the system
    """
    if request.method == "POST":
        request.user.doctor.delete()
        request.user.delete()
        return redirect('/')
    context = {}
    return render(request, 'delete_account.html', context)
\end{python}

HOW-R-U web interface icons have been gathered from \cite{pixabay}
\newpage
\subsection{Docker}

HOW-R-U development environment is composed of four main containers: conversational agent, web interface, database and reverse proxy. The containers use volumes, so that changes made to their files take effect inmediately, avoiding an environment restart to test them. The \emph{docker-compose} specification is the following one:

\begin{lstlisting}[language=docker-compose-2, caption={HOW-R-U docker-compose file}, captionpos=b]
version: "3.1"
services:
  conversational-agent:
    image: conversational-agent
    links:
        - db:db
    volumes:
        - ~/Documents/TFG1920/howru/howru_chatbot:/opt/chatbot
    depends_on:
      - db
    restart: always
  db:
    image: postgres
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    restart: always
  web-interface:
    image: web_interface
    links:
        - db:db
    volumes:
      - ~/Documents/TFG1920/howru/howru_web_interface:/opt/web_interface
    ports:
      - "8080:8080"
    depends_on:
      - proxy
      - db
    restart: always
  proxy:
    image: proxy
    ports:
      - "85:85"
    volumes:
      - ./proxy:/etc/nginx/conf.d
    restart: always
\end{lstlisting}

The individual \emph{Dockerfiles} of the previous containers are the following ones:

\begin{lstlisting}[language=docker, caption={HOW-R-U conversational agent Dockerfile}, captionpos=b]
FROM python:3.6.10-stretch

# Install requirements

ADD config/requirements.txt /root/requirements.txt
ADD config/routes.json /etc/howru/cfg/routes.json
RUN pip install -r /root/requirements.txt

# iPython for debugging
RUN pip3.6 install ipython

# Set PYTHONPATH
ENV PYTHONPATH /opt/chatbot

# Run bot
WORKDIR /opt/chatbot
CMD python3 manage.py makemigrations && \
    python3 manage.py migrate && \
    python3 src/bot.py
#CMD    tail -f /dev/null
\end{lstlisting}

\begin{lstlisting}[language=nginx, caption={HOW-R-U web interface Dockerfile}, captionpos=b]
FROM python:3.6.10-stretch
ENV PYTHONUNBUFFERED 1

# Copy config files
ADD config/requirements.txt /root/requirements.txt
ADD config/routes.json /etc/howru/cfg/routes.json
ADD config/initial_data.json /initial_data.json

# Install dependencies
RUN pip install -r /root/requirements.txt

# iPython for debugging
RUN pip3.6 install ipython

# Set workdir
WORKDIR /opt/web_interface

# Run server
CMD python3 manage.py makemigrations && \
    python3 manage.py migrate && \
    python3 manage.py loaddata /initial_data.json && \
    python3 manage.py runserver 0:8080
#CMD tail -f /dev/null
\end{lstlisting}

\begin{lstlisting}[language=docker, caption={HOW-R-U web reverse proxy Dockerfile}, captionpos=b]
FROM nginx:latest
COPY web_interface.conf /etc/nginx/conf.d/web_interface.conf
\end{lstlisting}

The reverse proxy configuration file just indicates the port where the web interface will be hosted:
\begin{lstlisting}[language=nginx, mathescape=false, caption={HOW-R-U web reverse proxy configuration file}, captionpos=b]
server {
    listen      85;
    location / {
        proxy_pass http://localhost:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
\end{lstlisting}


\section{Environment setup}
\label{sec:env_setup}

\subsection{Development environment}

The development environment will be deployed using \cite{docker}. To do that, the user just needs to install \emph{Docker}, clone the code repository and run the attached script:

\begin{lstlisting}[mathescape=false, language=bash, caption={Commands to deploy development environment}, captionpos=b]
  $> git clone https://github.com/csp98/TFG1920
  $> cd howru/docker
  $> ./start.sh
\end{lstlisting}

The \emph{start.sh} scripts build all the images and then launches them in \emph{docker}:

\begin{lstlisting}[language=bash, caption={start.sh script}, captionpos=b]
#!/bin/zsh
# Chatbot
docker build -t psychologist-bot chatbot

# Web interface
docker build -t web_interface web_interface
docker build -t proxy proxy

docker-compose -p "howru" up -d --remove-orphans --force-recreate
\end{lstlisting}
\newpage

\subsection{Production environment}

The production environment will be deployed using \emph{Amazon Web Services}. There will be three tipes of instances: psychologist bot, web interface and databases.

\subsubsection{Pre-deployment: Telegram bot creation}

The first step is to create the production conversational agent in Telegram. To do so, the user must establish a conversation with \emph{@BotFather} and send the bot creation commands:

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{bot_creation.png}
  \caption{Telegram bot creation}
\end{figure}

\emph{@BotFather} will provide the user with a private authentication token that HOW-R-U will use to control the conversational agent. The user can customize the bot by adding a profile picture, changing description, etc. by using the related \emph{@BotFather} commands.

\subsubsection{System deployment}

The next step is to deploy the system into AWS. The first component that is going to be deployed will be the database.

The user has to log in into \emph{Amazon Relational Database System (RDS)} and create a PostgreSQL database, setting an username and password. The user can use this tutorial as reference: \href{https://aws.amazon.com/getting-started/tutorials/create-connect-postgresql-db/}{https://aws.amazon.com/getting-started/tutorials/create-connect-postgresql-db/}.


\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{db_creation.png}
  \caption{Database instance being created}
\end{figure}

Then, the chatbot and web interface instances should be created using EC2. They should work under a Linux distribution. The web interface needs an specific rule in the security group so that it can be accessed from outside (port 80, HTTP):

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{web_int_sg.png}
  \caption{Security group rule for web interface instance}
\end{figure}

The next step is to deploy the web interface. To do so, the user must clone the repository from the instance:

\begin{lstlisting}[mathescape=false, language=bash, caption={Commands to download web interface repository}, captionpos=b]
  web_interface > sudo su
  web_interface > yum install git
  web_interface > mkdir /opt/web_interface
  web_interface > cd /opt/web_interface
  web_interface > git clone --recurse-submodules https://github.com/csp98/howru_web_interface.git .
\end{lstlisting}

Now we should configure four parameters: DB routes file, debug mode (should be disabled), allowed hosts and Django secret key. The first one consists on creating a file (\emph{/etc/howru/cfg/routes.json}) with the following content:

\begin{lstlisting}[caption={Routes file}, captionpos=b]
{
  "host": "<DB instance DNS>",
  "port": 5432,
  "name": "postgres",
  "user": "<DB username>",
  "password": "<DB password>"
}
\end{lstlisting}

The Django secret key can be generated with the following website: \href{https://miniwebtool.com/django-secret-key-generator/}{https://miniwebtool.com/django-secret-key-generator/}. Once retrieved, the user should create the following file:

\begin{lstlisting}[mathescape=false, language=bash, caption={Command to create Django key file}, captionpos=b]
  web_interface > nano /opt/web_interface/core/key.py
\end{lstlisting}

\begin{python}[caption={Django key file contents}, captionpos=b]
  KEY = '<KEY>'
\end{python}

Finally, the user must edit \emph{/opt/web\_interface/core/settings.py} setting \emph{DEBUG=False} and \emph{ALLOWED\_HOSTS = [*']}

The environment files are now ready. The next steps consist on installing \emph{Python}, the requirements and running the server.

\begin{lstlisting}[mathescape=false, language=bash]
web_interface > yum install python3 python3-pip python-psycopg2 postgresql gcc python3-devel
web_interface > pip3 install -r requirements.txt
web_interface > python3 manage.py makemigrations
web_interface > python3 manage.py migrate
\end{lstlisting}

Finally, we will configure \emph{screen} to detach the session where the interface will run:

\begin{lstlisting}[mathescape=false, language=bash]
web_interface > yum install screen
web_interface > screen
web_interface > python3 manage.py runserver 0:80
\end{lstlisting}

And finally press \emph{Ctrl+A+D} and close the SSH session. The web interface is now successfully configured and deployed and doctors can now use it by accessing through the public DNS.

Finally, let's deploy the conversational agent. Log in into the instance via SSH and do the following:

\begin{lstlisting}[mathescape=false, language=bash]
conv_agent > sudo su
conv_agent > yum install python3 python3-pip python3-devel git screen
conv_agent > mkdir /opt/chatbot
conv_agent > cd /opt/chatbot
conv_agent > git clone --recurse-submodules https://github.com/csp98/howru_chatbot.git .
\end{lstlisting}

Create the routes file (same as the web interface one) in the same directory. After that, the file with the bot secret token, \emph{/opt/chatbot/config/bot\_config.py}, and add the following:
\begin{python}
TOKEN = "<SECRET TOKEN>"
\end{python}

Now install the requirements, detach the screen and launch the conversational agent:

\begin{lstlisting}[mathescape=false, language=bash]
conv_agent > python3 -m pip install -r requirements.txt
conv_agent > export PYTHONPATH=`pwd`
conv_agent > export DJANGO_SETTINGS_MODULE="manage.settings"
conv_agent > python3 manage.py makemigrations
conv_agent > python3 manage.py migrate
conv_agent > python3 src/bot.py
\end{lstlisting}

After that, HOW-R-U system is ready to be used.

\begin{figure}[H]
  \centering
    \includegraphics[width=\textwidth]{production.png}
    \caption{HOW-R-U production conversational agent}
\end{figure}


\section{Discussion}
fortalezas y debilidades (no como lista)

\section{Conclusions}
revisión de objetivos logrados y no logrados

\newpage
\bibliographystyle{apacite}
\bibliography{refs}
\doclicenseThis

\end{document}
